﻿﻿﻿<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<# 
/*
 * T4ResX
 * Author  Robert Hoffmann (itechnology)
 * License MIT / http://bit.ly/mit-license
 * 
 * Version 1.00
 * https://github.com/itechnology/T4ResX
 */
#>
<# 
	/* CONFIGURATION SETTINGS
	 ************************/

	// If you are using this in an assembly where adding a RESX adds a code behind designer.cs file, then be sure to set this to true
	// Otherwise the designer.cs and the T4ResX.cs will contain the same namespaces and compilation will fail
	// Classic ASP.NET websites do not generate designer files in the codebehind
	var removeDesignerFiles = true;

	/* CONFIGURATION SETTINGS
	 ************************/

	/* T4ResX: Find all RESX files
	 * Not alot to see here .. :)
	 * All the important stuff is in T4Helper & T4ResXHelpers
	 * Make this alot easier to maintain and elaborate outside of the .tt environement
	 **********************************************************************************/
	T4Helper = new DteHelper(this.Host);

	var projectItems  = T4Helper.GetAllProjectItems();
	var project       = T4Helper.GetProject(T4Helper.GetCurrentProjectName());
	var projectPath   = System.IO.Path.GetDirectoryName(project.FileName);
	var rootNameSpace = project.Properties.Item("RootNamespace").Value.ToString();

	var items = new List<T4ResXHelpers.ResXItem>();

	//System.Diagnostics.Debugger.Break();

	projectItems
		.ToList()
		.ForEach(projectItem => {
			var itemPath = T4Helper.GetProjectItemFullPath(projectItem);

			if (itemPath.EndsWith(".resx")) {				
				if (removeDesignerFiles  && !Regex.IsMatch(itemPath, T4ResXHelpers.CultureInvariantRegex, RegexOptions.IgnoreCase)) {
					T4Helper.SetPropertyValue(projectItem, "CustomTool", "");                  
				}

				T4ResXHelpers.AddResX(projectPath, rootNameSpace, itemPath, items);	
			}
	});
 #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

/*
 * T4ResX
 * Author  Robert Hoffmann (itechnology)
 * License MIT / http://bit.ly/mit-license
 *
 * Version 1.00
 * https://github.com/itechnology/T4ResX
 */ 
 using System;
 using System.Linq; 
 using System.Threading;
 using System.Reflection;
 using System.Collections.Generic; 
 using System.Text.RegularExpressions;
 using Shrooms.Resources.Helpers;

 namespace <#= rootNameSpace #> {
	/// <summary>
	/// Class that contains all our little helper functions
	/// </summary>
	public static class Utilities {
		/// <summary>
		/// A fake attribute that allows us to filter classes by Attribute
		/// It's helpfull when using GetResourcesByNameSpace(), and when T4ResX is tossed into a project containing other classes/properties
		/// Like this we only return stuff generated by T4ResX itself
		/// </summary>
		public class Localized : Attribute {}

		///<summary>
		/// We bind this function to our replacement function when needed
		/// Like this the replacement function can reside in any assembly you like
		/// Bind it once on ApplicationStart, or rebind it to a different replacement function before calling it
		///
		/// Poor Man's IOC
		/// http://www.i-technology.net
		///</summary>
		public static Func<string, string> GetReplacementString = key => key;
		
		#region Methods
		
		public static string GetLocalizedJs(string ns)
		{
			return string.Format("var ResX = {0};", Utilities.GetResourcesByNameSpace(ns).ToJson());
		}

		/// <summary>
		/// Look up ressources from a specific namespace
		/// </summary>
		/// <param name="ns">Namspace to get resources from</param>
		/// <returns>Dictionary&lt;namespace, Dictionary&lt;key, value&gt;&gt;</returns>
		public static Dictionary<string, Dictionary<string, string>> GetResourcesByNameSpace(string ns)
		{
			var result = new Dictionary<string, Dictionary<string, string>>();

			if (ns == null)
				ns = string.Empty;

			var qs = ns.Split('^');
				ns = qs[0];

			var path  = string.IsNullOrEmpty(ns) ? "<#= rootNameSpace #>" : ns;
			var wCard = path;

			if (ns.EndsWith(".*"))
			{
				wCard = path.Replace(".*", "");
			}
			
			var current = Assembly.GetExecutingAssembly();
			current
				.GetTypes()
				.Where(type => type.GetCustomAttributes(typeof(Localized), false).Length != 0)
				.Where(type => type.Namespace != null && (ns == "" || (ns.EndsWith(".*")
																		   ? type.Namespace.StartsWith(wCard, StringComparison.InvariantCultureIgnoreCase)
																		   : string.Equals(type.Namespace, path, StringComparison.InvariantCultureIgnoreCase)))
				 )
				.Where(type => qs.Length != 2 || Regex.IsMatch(type.Name, qs[1], RegexOptions.CultureInvariant | RegexOptions.IgnoreCase | RegexOptions.Singleline))
				.ToList()
				.ForEach(typeFound =>
				{
					var instance = current.CreateInstance(typeFound.FullName);
					if (instance != null)
					{
						var instanceType  = instance.GetType();
						var instanceClass = instanceType.FullName.Replace(wCard, "");
						var propertyList  = new Dictionary<string, string>();

						instanceType
							.GetProperties()
							.Where(t => t.GetCustomAttributes(typeof(Localized), false).Length != 0)
							.ToList()
							.ForEach(property => propertyList.Add(property.Name, property.GetValue(null, null).ToString()));

						if (propertyList.Count > 0)
						{
							result.Add(instanceClass.StartsWith(".") ? instanceClass.Substring(1) : instanceClass, propertyList);
						}
					}
				});

			return result;
		}
		#endregion
	}
 }
	<# 
	var currentClassName = string.Empty;
	var writeClassHeader = false;

	// We only want culture invariant entries for now
	var resxItems = items.Where(c => string.IsNullOrEmpty(c.Culture));
		
	foreach (T4ResXHelpers.ResXItem item in resxItems) {	
		// Since we are lazy writing everything below with partial classes, we need to know when we can or cannot add the ResourceManager
		if (string.Equals(currentClassName, item.ClassName))
		{
			writeClassHeader = false;
		}
		else
		{
			writeClassHeader = true;
			currentClassName = item.ClassName;			
		}					
	#>

namespace <#= T4ResXHelpers.Current.NormalizeString(item.NameSpace)#>  {
	<# if (writeClassHeader){ Write("[Utilities.Localized]"); } #>	
	public partial class <#= item.ClassName #> {
	<#
		// If we are entering a new class, we must add some functions to the top of it
		if (writeClassHeader)
		{
			var path =	T4ResXHelpers.Current.NormalizeString(item.NameSpace.Replace(rootNameSpace, "")) + "^" + item.ClassName;
			if (path.StartsWith(".")) {
				path = path.Substring(1);
			}
	#>

		///<summary>
		/// Return this class as a Dictionary&lt;class, Dictionary&lt;key, value&gt;&gt;
		///</summary>
		public static Dictionary<string, Dictionary<string, string>> GetAsDictionary() {
			return Utilities.GetResourcesByNameSpace("<#=path#>");
		}

		private static System.Resources.ResourceManager _resourceManager;    
	
		///<summary>
		/// Get the ResourceManager
		///</summary>
		private static System.Resources.ResourceManager ResourceManager 
		{
			get 
			{
				return _resourceManager ?? (_resourceManager = new System.Resources.ResourceManager("<#=T4ResXHelpers.Current.NormalizeString(item.NameSpace)#>.<#=item.ClassName#>", typeof(<#=item.ClassName#>).Assembly));
			}
		}

		///<summary>
		///	Get localized entry for a given key
		///</summary>
		public static string GetResourceString(string key, params object[] args)
		{
			var value = ResourceManager.GetString(key, Thread.CurrentThread.CurrentCulture);

			if (!string.IsNullOrEmpty(value))
			{
				var regex  = @"{\b\p{Lu}{3,}\b}";
				var tokens = Regex.Matches(value, regex).Cast<Match>().Select(m => m.Value).ToList();
					tokens
						.ForEach(t =>
						{
							value = value.Replace(t, Utilities.GetReplacementString(t.Replace("{", "").Replace("}", "")));
						});

				if (args.Any())
				{
					regex  = @"{[0-9]{1}}";
					tokens = Regex.Matches(value, regex).Cast<Match>().Select(m => m.Value).ToList();

					if (tokens.Any())
					{
						// If argument length is less than token length, add an error message
						// This can happen if arguments are accidentally forgottent in a translation
						if (args.Count() < tokens.Count())
						{
							var newArgs = new List<object>();
							for (var i = 0; i < tokens.Count(); i++)
							{
								newArgs.Add(args.Length > i ? args[i] : "argument {" + i + "} is undefined");
							}

							args = newArgs.ToArray();
						}

						value = string.Format(value, args);
					}
				}		        		
			}
	
			return value;
		} 
		<#
		} // END writeClassHeader
		if (T4ResXHelpers.Current.HasTokens(item.Value)) {
		#>

		///<summary>
		///    <list type='bullet'>
		///        <item>
		///            <description><#= T4ResXHelpers.Current.NormalizeCSharpComment(item.Value)#></description>
		///        </item>
		///        <item>
		///            <description><#= T4ResXHelpers.Current.NormalizeCSharpComment(item.Comment)#></description>
		///        </item>
		///    </list>
		///</summary>
		public static string <#= T4ResXHelpers.Current.NormalizeItem(item.Key, false)#>Formatted(params object[] args) { return GetResourceString("<#=T4ResXHelpers.Current.NormalizeItem(item.Key, false)#>", args); }
		<#
		} // END HasTokens(item.Value)
		#>

		///<summary>
		///    <list type='bullet'>
		///        <item>
		///            <description><#= T4ResXHelpers.Current.NormalizeCSharpComment(item.Value)#></description>
		///        </item>
		///        <item>
		///            <description><#= T4ResXHelpers.Current.NormalizeCSharpComment(item.Comment)#></description>
		///        </item>
		///    </list>
		///</summary>
		[Utilities.Localized]
		public static string <#= T4ResXHelpers.Current.NormalizeItem(item.Key, false)#> { get { return GetResourceString(<#=T4ResXHelpers.Current.NormalizeItem(item.Key, false)#>Key); } }

		/// <summary>
		/// Resource key for <see cref="<#= T4ResXHelpers.Current.NormalizeItem(item.Key, false)#>"/>
		/// You can use it e.g. in validation attributes for <see cref="System.ComponentModel.DataAnnotations.ValidationAttribute.ErrorMessageResourceName"/> parameter.
		/// </summary>
		public const string <#=T4ResXHelpers.Current.NormalizeItem(item.Key, false)#>Key = "<#=item.Key#>";

		<# 
		if ((T4ResXHelpers.Current.GetType(item.Comment) & T4ResXHelpers.ResxType.Constant) == T4ResXHelpers.ResxType.Constant) {	
		#>

		///<summary>
		///    <list type='bullet'>
		///        <item>
		///            <description><#= T4ResXHelpers.Current.NormalizeCSharpComment(item.Value)#></description>
		///        </item>
		///        <item>
		///            <description><#= T4ResXHelpers.Current.NormalizeCSharpComment(item.Comment)#></description>
		///        </item>
		///        <item>
		///            <description>
		///					There are places where we cannot use strings as they are considered dynamic
		///					
		///					[RegularExpressionAttribute(User.PseudoRegexConstant, ErrorMessageResourceName = "PseudoError", ErrorMessageResourceType = typeof(User))]
		///
		///					However:
		///					constant = no dynamic content
		///					If you have an idea of how to make constants dynamically localizable, let me know !
		///				</description>
		///        </item>
		///    </list>
		///</summary>	
		public const string <#=T4ResXHelpers.Current.NormalizeItem(item.Key, false)#>Constant = "<#=item.Value.Replace("\r", "").Replace("\n", " ")#>";
		<#
		} // END T4ResXHelpers.Current.GetType(item.Comment)
		#>

	}
}
<#
	} // END foreach
#>
<#+
	#region I-Technology.NET T4 Helpers
	/// <summary>
	/// 
	/// INFO: to be included at the bottom of the T4 file
	/// </summary>
	public class T4ResXHelpers
	{
		#region Singleton
		// http://www.yoda.arachsys.com/csharp/singleton.html (Fourth: Simplified)
		/// <summary>
		/// Public instance to Helpers
		/// </summary>
		public static readonly T4ResXHelpers Current = new T4ResXHelpers();

		// Explicit static constructor to tell C# compiler
		// not to mark type as beforefieldinit
		static T4ResXHelpers() { }

		T4ResXHelpers()
		{
			// Eventual init code
		}
		#endregion

		/// <summary>
		/// Determine the processing level. Not used yet.
		/// </summary>
		public enum ProcessLevel
		{
			/// <summary>
			/// Process all files from Folder recursive, in which T4ResX.tt resides
			/// </summary>
			Folder,

			/// <summary>
			/// Process all files from Project recursive, in which T4ResX.tt resides
			/// </summary>
			Project
		}

		/// <summary>
		/// Declared type of entry. Not used yet.
		/// </summary>
		[Flags]
		public enum ResxType
		{
			None     = 0,
			Constant = 1
		}

		/// <summary>
		/// Template used for each RESX item discovered
		/// </summary>
		public class ResXItem
		{
			public string NameSpace { get; set; }
			public string ClassName { get; set; }

			public string Key       { get; set; }
			public string Value     { get; set; }
			public string Comment   { get; set; }
			public string Culture   { get; set; }
		}

		/// <summary>
		/// Match files without culture extension
		/// </summary>
		public const string CultureInvariantRegex = @".*\.[a-z]{2}(-[a-z]{2})?\.resx$";

		/// <summary>
		/// Finds tokens in the form of {NAME}
		/// </summary>
		public const string NamedTokenRegex = @"{\b\p{Lu}{3,}\b}";

		/// <summary>
		/// Finds tokens in the form of {0}
		/// </summary>
		public const string ParamTokenRegex = @"{[0-9]{1}}";

		/// <summary>
		/// Finds tokens in the form of {NAME} & {0}
		/// </summary>
		public const string AnyTokenRegex = @"{[0-9]{1}}|{\b\p{Lu}{3,}\b}";

		/// <summary>
		/// Get the declared type of an item
		/// INFO: Currently only constants works. This is open for future ideas.
		/// </summary>
		public ResxType GetType(string value)
		{
			var result = ResxType.None;

			if (Regex.IsMatch(value, @"\[type:constant\]"))
			{
				result |= ResxType.Constant;
			}

			return result;
		}

		/// <summary>
		/// See if the content contains any tokens
		/// </summary>
		public bool HasTokens(string content)
		{
			return Regex.IsMatch(content, AnyTokenRegex);
		}

		///<summary>
		/// Reformat a string to various forms
		///</summary>
		public string NormalizeString(string s)
		{
			bool isClass = true;

			return s.Split('.')
					.Aggregate((c, n) => NormalizeItem(c, isClass) + (isClass ? "." : "_") + NormalizeItem(n, isClass));
		}

		/// <summary>
		/// Same as above but single item
		/// </summary>
		public string NormalizeItem(string s, bool isClass)
		{
			bool camelCase = true;

			s = s.Replace(isClass ? "." : "_", "#");

			var r = @"[^\p{L}0-9#]";
			var m = Regex.Matches(s, r);

			foreach (Match match in m)
			{
				if (camelCase)
				{
					var chars              = s.ToCharArray();
					chars[match.Index + 1] = char.ToUpper(s[match.Index + 1]);
					s                      = new string(chars);
				}

				s = s.Remove(match.Index, 1);
				s = s.Insert(match.Index, "_");
			}

			if (Regex.IsMatch(s, @"^[0-9]"))
			{
				s = s.Insert(0, "_");
			}

			return s.Replace("#", isClass ? "." : "_");
		}

		/// <summary>
		/// Normalizes string, so it can be safely used in C# XML documentation comments
		/// </summary>
		public string NormalizeCSharpComment(string comment)
		{
			// This is practically same as System.Web.HttpUtility.HtmlEncode(), but you dont need System.Web assembly
			return System.Security.SecurityElement.Escape(comment.Replace("\r", "").Replace("\n", " "));
		}

		
		#region ResXLoading
		public static void AddResX(string projectPath, string rootNameSpace, string itemPath, List<ResXItem> items)
		{            
			var culture = CultureInfo.InvariantCulture;
			var file    = System.IO.Path.GetFileNameWithoutExtension(itemPath);
			try
			{
				if (file != null)
				{
					culture = CultureInfo.CreateSpecificCulture(file.Split('.').Last());
				}
			}
			catch
			{
				culture = CultureInfo.InvariantCulture;
			}

			var xml = new XmlDocument();
			xml.Load(itemPath);

			if (xml.DocumentElement != null)
			{
				var nodes = xml.DocumentElement.SelectNodes("//data");
				if (nodes != null)
				{
					foreach (XmlElement element in nodes)
					{
						var className = System.IO.Path.GetFileNameWithoutExtension(itemPath);
						var nameSpace = rootNameSpace + itemPath.Replace(projectPath, "").Replace("\\", ".").Replace("." + className + ".resx", "");

						var entry = new ResXItem
										{
											ClassName = className,
											NameSpace = nameSpace,

											Key       = string.Empty,
											Value     = string.Empty,
											Comment   = string.Empty,
											Culture   = culture.Name
										};

						var elementKey = element.Attributes.GetNamedItem("name");
						if (elementKey != null)
						{
							entry.Key = elementKey.Value ?? string.Empty;
						}

						var elementValue = element.SelectSingleNode("value");
						if (elementValue != null)
						{
							entry.Value = elementValue.InnerText;
						}

						var elementComment = element.SelectSingleNode("comment");
						if (elementComment != null)
						{
							entry.Comment = elementComment.InnerText;
						}

						items.Add(entry);
					}
				}
			}
		}
		#endregion      
	}
	#endregion

	#region TangibleT4 Helpers
	public DteHelper T4Helper;   

	/// <summary>
	/// Collection of Visual Studio Automation-Helper methods.
	/// </summary>
	/// <returns></returns>
	public class DteHelper 
	{
		public DteHelper(object host)
		{
			Host = host as ITextTemplatingEngineHost;
		}
	
		public EnvDTE.DTE Dte
		{
			get
			{
				return GetHostServiceProvider();
			}
		}
	
		private readonly ITextTemplatingEngineHost Host;
	
		/// Functions requires hostspecific true
		/// <summary>
		/// Gets the solution name of the project.
		/// </summary>
		public string GetSolutionName()
		{
			return Path.GetFileNameWithoutExtension(Dte.Solution.FullName);
		}
	
		public EnvDTE.Project GetProject(string projectName)
		{
			var projects = GetAllProjects();
			return projects.First(p => p.Name == projectName);
		}
	
		/// <summary>
		/// Get all projects of the solution.
		/// Works not with nested solutions folders.
		/// </summary>
		/// <returns></returns>
		public IEnumerable<EnvDTE.Project> GetAllProjects()
		{
			var projectList = new List<EnvDTE.Project>();
		
			var folders = Dte.Solution.Projects.Cast<EnvDTE.Project>().Where(p => p.Kind == EnvDTE80.ProjectKinds.vsProjectKindSolutionFolder);
				
			foreach (EnvDTE.Project folder in folders)
			{
				projectList.AddRange(GetProjectItems(folder.ProjectItems));				
			}
		
			var projects = Dte.Solution.Projects.Cast<EnvDTE.Project>().Where(p => p.Kind != EnvDTE80.ProjectKinds.vsProjectKindSolutionFolder);
			if (projects.Any())
			{
				projectList.AddRange(projects);
			}
		
			return projectList;
		}

		public IEnumerable<EnvDTE.Project> GetProjectItems(EnvDTE.ProjectItems projectItems)
		{
			var projectList = new List<EnvDTE.Project>();

			if (projectItems != null) 
			{
				foreach (EnvDTE.ProjectItem item in projectItems)
				{
					if (item.Object is EnvDTE.Project)
					{
						projectList.Add(item.Object as EnvDTE.Project);

						var folder = item.Object as EnvDTE.Project;
						projectList.AddRange(GetProjectItems(folder.ProjectItems));
					}
				}
			}

			return projectList;
		}

		public IEnumerable<EnvDTE.ProjectItem> GetAllSolutionItems()
		{
			var itemList = new List<EnvDTE.ProjectItem>();
			foreach (EnvDTE.Project item in GetAllProjects())
			{
				if (item == null || item.ProjectItems == null)
				{
					continue;
				}
			
				itemList.AddRange(GetAllProjectItemsRecursive(item.ProjectItems));	 
			}
		
			return itemList;
		}
	
		public IEnumerable<EnvDTE.ProjectItem> GetAllProjectItems()
		{
			return GetAllProjectItemsRecursive(GetTemplateAsProjectItem(Dte).ContainingProject.ProjectItems);
		}
	
		public IEnumerable<EnvDTE.ProjectItem> GetAllProjectItemsRecursive(EnvDTE.ProjectItems projectItems) 
		{
			foreach (EnvDTE.ProjectItem projectItem in projectItems) 
			{
				if (projectItem.ProjectItems == null)
				{
					continue;
				}

				foreach (EnvDTE.ProjectItem subItem in GetAllProjectItemsRecursive(projectItem.ProjectItems))
				{
					yield return subItem;
				}
			
				yield return projectItem;
			}
		}
	
		public string GetProjectItemFullPath(EnvDTE.ProjectItem item)
		{
			return item.Properties.Item("FullPath").Value.ToString();
		}
	
		/// <summary>
		/// Gets the project name of the active template file.
		/// </summary>
		public string GetCurrentProjectName()
		{
			return Dte.ActiveDocument.ProjectItem.ContainingProject.Name;
		}

		/// <summary>
		/// Sets the custom tool for generated item.
		/// <param name="generatedFilename">Filename of the generated item</param>
		/// <param name="customToolName">The name of the custom tool.</param>
		/// <example>
		/// 	SetCustomToolForGeneratedItem("Resource.resx", "ResXFileCodeGenerator");
		/// </example>
		/// </summary>
		public void SetCustomToolForGeneratedItem(string generatedFilename, string customToolName)
		{
			EnvDTE.ProjectItem subItem = GetTemplateAsProjectItem(Dte).ProjectItems.Cast<EnvDTE.ProjectItem>().First(p => p.Name == generatedFilename);
		
			SetPropertyValue(subItem, "CustomTool", customToolName);
		}

		/// <summary>
		/// Sets the custom tool for the first generated item.
		/// <param name="customToolName">The name of the custom tool.</param>
		/// <example>
		/// 	SetCustomToolForFirstGeneratedItem("ResXFileCodeGenerator");
		/// </example>
		/// </summary>
		public void SetCustomToolForFirstGeneratedItem(string customToolName)
		{
			EnvDTE.ProjectItem firstSubItem = GetTemplateAsProjectItem(Dte).ProjectItems.Cast<EnvDTE.ProjectItem>().First();

			SetPropertyValue(firstSubItem, "CustomTool", customToolName);
		}

		/// <summary>
		/// Sets a property value for the project item.
		/// </summary>
		public void SetPropertyValue(EnvDTE.ProjectItem item, string propertyName, object value)
		{
			EnvDTE.Property property = item.Properties.Item(propertyName);

			if (property == null)
			{
				throw new ArgumentException(String.Format("The property {0} was not found.", propertyName));
			}

			property.Value = value;
		}

		/// <summary>
		/// Gets the T4 template as vs projectitem.
		/// </summary>
		public EnvDTE.ProjectItem GetTemplateAsProjectItem(EnvDTE.DTE dte)
		{
			return dte.Solution.FindProjectItem(Host.TemplateFile);
		}

		/// <summary>
		/// Adds a missing file to the t4 vs projectitem.
		/// </summary>
		public void AddMissingFileToProject(EnvDTE.ProjectItem pItem, string fileName)
		{
			var isMissing = !(from itm in pItem.ProjectItems.Cast<EnvDTE.ProjectItem>()
							  where itm.Name == fileName
							  select itm).Any();

			if (isMissing)
			{
				pItem.ProjectItems.AddFromFile(GetPath(fileName));
			}	
		}

		/// <summary>
		/// Gets the vs automation object EnvDTE.DTE.
		/// </summary>
		public EnvDTE.DTE GetHostServiceProvider()
		{
			var hostServiceProvider = Host as IServiceProvider;
			EnvDTE.DTE dte = null;
			if (hostServiceProvider != null)
			{
				dte = hostServiceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
			}

			return dte;
		}
	
		/// <summary>
		/// Gets the full path of the file.
		/// </summary>
		public string GetPath(string fileName)
		{
			string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
			if (templateDirectory != null)
			{
				return Path.Combine(templateDirectory, fileName);
			}

			return null;
		}
	}
	#endregion
#>